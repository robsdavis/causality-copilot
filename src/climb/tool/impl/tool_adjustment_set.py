import os
from typing import Any, Optional, Dict
import pickle as pkl

import numpy as np
import pandas as pd
import networkx as nx
from pathlib import Path
from sklearn.linear_model import LinearRegression
from optimaladj.CausalGraph import CausalGraph

from ..tool_comms import ToolCommunicator, ToolReturnIter, execute_tool
from ..tools import ToolBase

def cpdag_to_causal_graph(cpdag):
    """
    Converts an updated CPDAG (with directed edges set by expert knowledge)
    into an instance of optimaladj's CausalGraph.
    
    Parameters:
      cpdag: The CPDAG object generated by causal_learn. It should have the 
             attributes 'graph' (a NumPy array) and 'node_names' (a list of nodes).
    
    Returns:
      cg: A CausalGraph instance with the nodes and directed edges from cpdag.
    """
    # Instantiate an empty CausalGraph.
    cg = CausalGraph()
    
    # Add all nodes to the CausalGraph.
    for node in cpdag.node_names:
        cg.add_node(node)
    
    # Get the number of nodes.
    n = len(cpdag.node_names)
    
    # Iterate over the matrix and add directed edges.
    for i in range(n):
        for j in range(n):
            # According to your convention, a directed edge from node i to node j is marked by -1.
            if cpdag.graph[i, j] == -1:
                source = cpdag.node_names[i]
                target = cpdag.node_names[j]
                cg.add_edge(source, target)
    
    return cg

def load_causal_graph(dag_pickle_path):
    """
    Loads the serialized dag from the pickle file and converts it into a CausalGraph.

    Parameters
    ----------
    dag_pickle_path : str or Path
        Path to the serialized dag pickle file.

    Returns
    ----------
    causal_graph : CausalGraph
        A CausalGraph instance constructed directly from the NumPy array stored in the dag.
    """
    dag_pickle_path = Path(dag_pickle_path)
    # Load the serialized dag (which contains a NumPy array as its graph)
    with open(dag_pickle_path, "rb") as f:
        dag = pkl.load(f)

    # Ensure node_names exist: if not, generate generic ones.
    if hasattr(dag, "node_names"):
        node_names = list(dag.node_names)
    else:
        n = dag.graph.shape[0]
        node_names = [f"X{i}" for i in range(n)]
        dag.node_names = node_names

    causal_graph = cpdag_to_causal_graph(dag)
    print(causal_graph)

    return causal_graph

def treatment_in_causal_vertices(causal_graph, treatment, outcome):
    causal_vertices = set()
    causal_paths = list(nx.all_simple_paths(causal_graph, source=treatment, target=outcome))
    for path in causal_paths:
        causal_vertices = causal_vertices.union(set(path))
    if treatment in causal_vertices:
        return True
    return False

def compute_adj_sets(
    tc: ToolCommunicator,
    dag_pickle_path: str,
    treatment: str,
    outcome: str,
) -> None:
    """
    Loads a serialized DAG from a pickle file as a causal graph and computes optimal adjustment sets.

    This function performs the following steps:
      1) Loads the DAG from the provided dag_pickle_path and converts it into a CausalGraph.
      2) Sets L to an empty list, and N to all features (i.e. all nodes in the causal graph).
      3) Calls each of these functions safely (catching exceptions that may be raised as ConditionException errors):
            a) causal_graph.optimal_adj_set(treatment, outcome, L, N)
            b) causal_graph.optimal_minimal_adj_set(treatment, outcome, L, N)
            c) causal_graph.optimal_minimum_adj_set(treatment, outcome, L, N)
      4) Returns a dictionary with the following keys:
         {
             "optimal adjustment set": <list from optimal_adj_set or empty list on error>,
             "optimal minimal adjustment set": <list from optimal_minimal_adj_set or empty list on error>,
             "optimal minimum adjustment set": <list from optimal_minimum_adj_set or empty list on error>,
         }

    Parameters:
      - tc: ToolCommunicator for logging and setting returns.
      - dag_pickle_path (str): Path to the serialized DAG (pickle file).
      - treatment (str): Name of the treatment variable.
      - outcome (str): Name of the outcome variable.
    
    Note:
      - L is always set to an empty list.
      - N is set to all nodes (features) in the causal graph.
    """
    # Load the serialized DAG from the pickle file.
    try:
        causal_graph = load_causal_graph(dag_pickle_path)
    except Exception as e:
        tc.print("Error loading the DAG:", e)
        tc.set_returns(
            tool_return="Error loading the DAG. Please make sure you have run the DAG generation tool first and provided the correct path to the DAG pickle file.",
            user_report=["Error loading the DAG. Please make sure you have run the DAG generation tool first and provided the correct path to the DAG pickle file."],
        )
        return
    
    # raise error if treatment or outcome not in the causal vertices
    if not treatment_in_causal_vertices(causal_graph, treatment, outcome):
        tc.print(f"""Error: Treatment variable '{treatment}' is not in the causal graph. Please make sure that you have provided the correct treatment variable and \
that the causal graph includes at least one causal path between the treatment ({treatment}) and the outcome {outcome}.""")
        tc.set_returns(
            tool_return=[f"""Error: Treatment variable '{treatment}' is not in the causal graph. Please make sure that you have provided the correct treatment variable and \
that the causal graph includes at least one causal path between the treatment ({treatment}) and the outcome {outcome}."""],
            user_report=[f"""Error: Treatment variable '{treatment}' is not in the causal graph. Please make sure that you have provided the correct treatment variable and \
that the causal graph includes at least one causal path between the treatment ({treatment}) and the outcome {outcome}."""],
        )
        return


    # Set L to empty list and N to all nodes in the causal graph.
    L = []
    N = list(causal_graph.nodes())

    # Call each adjustment set function safely.
    success = True
    try:
        optimal_adj = causal_graph.optimal_adj_set(treatment, outcome, L, N)
        tc.print("Optimal adjustment set:", optimal_adj)
    except Exception as e:
        tc.print("Error in optimal_adj_set:", e)
        optimal_adj = {}
        success = False
    try:
        optimal_minimal_adj = causal_graph.optimal_minimal_adj_set(treatment, outcome, L, N)
        tc.print("Optimal minimal adjustment set:", optimal_minimal_adj)
    except Exception as e:
        tc.print("Error in optimal_minimal_adj_set:", e)
        optimal_minimal_adj = {}
        success = False
    try:
        optimal_minimum_adj = causal_graph.optimal_minimum_adj_set(treatment, outcome, L, N)
        tc.print("Optimal minimum adjustment set:", optimal_minimum_adj)
    except Exception as e:
        tc.print("Error in optimal_minimum_adj_set:", e)
        optimal_minimum_adj = {}
        success = False

    results = {
        "optimal adjustment set": optimal_adj,
        "optimal minimal adjustment set": optimal_minimal_adj,
        "optimal minimum adjustment set": optimal_minimum_adj,
    }

    tc.print("Optimal adjustment sets computed.")
    # check for empty sets
    if optimal_adj == {} and optimal_minimal_adj == {} and optimal_minimum_adj == {} and success:
        tc.print("""Optimal adjustment sets are empty. This likely means there are no non-causal backdoor paths linking the treatment and outcome.\
Check the causal graph to see if this is true by looking for causal paths between the treatment and the outcome. If there is only one causal path between \
treatment and outcome, we will simply regress on the treatment as it has a direct causal link.""")


    tc.set_returns(
        tool_return="Optimal adjustment sets computed.",
        user_report=[
            f"Optimal adjustment set: {optimal_adj}",
            f"Optimal minimal adjustment set: {optimal_minimal_adj}",
            f"Optimal minimum adjustment set: {optimal_minimum_adj}",
        ],
    )
    return results

class ComputeOptimalAdjSets(ToolBase):
    def _execute(self, **kwargs: Any) -> ToolReturnIter:
        dag_pickle_path = os.path.join(self.working_directory, kwargs["dag_pickle_path"])
        treatment = kwargs["treatment"]
        outcome = kwargs["outcome"]
        thrd, out_stream = execute_tool(
            compute_adj_sets,
            dag_pickle_path=dag_pickle_path,
            treatment=treatment,
            outcome=outcome,
            # ---
            wd=self.working_directory,
        )
        self.tool_thread = thrd
        return out_stream

    @property
    def name(self) -> str:
        return "compute_optimal_adj_sets"

    @property
    def description(self) -> str:
        return (
            "Loads a serialized DAG as a causal graph and computes optimal adjustment sets using three functions: "
            "optimal_adj_set, optimal_minimal_adj_set, and optimal_minimum_adj_set. "
            "This tool always uses an empty list for L and sets N to all features in the dataset."
        )

    @property
    def specification(self) -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": self.name,
                "description": self.description,
                "parameters": {
                    "type": "object",
                    "properties": {
                        "dag_pickle_path": {
                            "type": "string",
                            "description": "Path to the serialized DAG (pickle file).",
                        },
                        "treatment": {
                            "type": "string",
                            "description": "Name of the treatment variable.",
                        },
                        "outcome": {
                            "type": "string",
                            "description": "Name of the outcome variable.",
                        },
                    },
                    "required": ["dag_pickle_path", "treatment", "outcome"],
                },
            },
        }

    @property
    def description_for_user(self) -> str:
        return (
            "Loads a serialized DAG as a causal graph and computes optimal adjustment sets. "
            "This tool always uses an empty list for L and considers all features in the dataset for N. "
            "It returns a dictionary with keys 'optimal adjustment set', 'optimal minimal adjustment set', and "
            "'optimal minimum adjustment set'."
        )
